% Chapter 2

\chapter{Internship work} % Main chapter title

\label{Chapter2} % For referencing the chapter elsewhere, use \ref{Chapter2}

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content
%\newcommand{\keyword}[1]{\textbf{#1}}
%\newcommand{\tabhead}[1]{\textbf{#1}}
%\newcommand{\code}[1]{\texttt{#1}}
%\newcommand{\file}[1]{\texttt{\bfseries#1}}
%\newcommand{\option}[1]{\texttt{\itshape#1}}
%\newcommand{\iBubble}{\textcolor{mdtRed}{\textsc{iBubble}}}
%\newcommand{\rasp}{\textcolor{mdtRed}{\textsc{Raspberry Pi}}}
%\newcommand{\vc}{\textcolor{mdtRed}{\textsc{VideoCore IV 3D}}}
%\newcommand{\cpu}{\textcolor{mdtRed}{\textsc{ARM CPU}}}
%\newcommand{\bcm}{\textcolor{mdtRed}{\textsc{BCM2837}}}
%\newcommand{\qpu}{\textcolor{mdtRed}{\textsc{QPU}}}
%\newcommand{\code}[1]{\texttt{\hl{#1}}}

%----------------------------------------------------------------------------------------

\section{State of the Art}

When arriving at \groupname{}, my first task was to write a \emph{State-of-the-Art} report about the \vc{}. The goal was to list interesting projects using this \keyword{GPU} and know what was possible to do with it.
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
So I spent my first two weeks surfing on the internet to gather every information I found about \vc. I wrote a report containing general information and every accurate project for the rest of my internship.

Finally I had a meeting with \supname{} where I explained to him which direction I wanted to explore. We decided that I should start with a \emph{\enquote{helloworld}} project that let me understand the basics of the \vc{} and start developping on a \rasp.

%----------------------------------------------------------------------------------------

\section{Raspberry Pi Playground}

\emph{Raspberry Pi Playground} \parencite{refRpiPlayground} is the first project I focused on to better understand the \vc. It is associated with a \enquote{\file{github}} repository, here : \url{//github.com/elorimer/rpi-playground}

It is the most important project I studied during my internship because it contains a \enquote{\file{helloworld}} program that helped me to understand the preliminary basis of the \vc{} architecture and above all how to use this \keyword{GPU}. I followed every step of this project permanantly reading the \vc{} documention \parencite{refVC}. I detail this program because all the rest of my internship is based on it.


\subsection{GPU Programming}
\label{concepts}
Before describing what the \file{helloworld} project does, I will highlight some \keyword{key points} in \vc{} programming that I understood with \parencite{refRpiPlayground}.

\begin{itemize}
	\item GPU is a CPU peripheral
	\item GPU and CPU share the same RAM memory
\end{itemize}

The first \keyword{key thing} to understand is that a \keyword{GPU} is driven by a host \keyword{CPU}. In the case of \bcm, the \vc{} is driven by an \cpu{}(ARM Cortex A53).

The second \keyword{key thing} is that they share the same \keyword{RAM} memory.

So to run \code{code} on \keyword{GPU}, the host \keyword{CPU} must \emph{map} a shared memory space between both processors. Then \keyword{CPU} send instructions and data using \emph{VC CPU Bus Addresses} and \keyword{GPU} give back results using \emph{ARM Virtual Adresses}.
Appendice~\ref{AppendixB} taken from the \bcm{} documentation \parencite{refBCM} shows this different address spaces.

These are really two crucial \keyword{concepts} to keep in mind for the rest of the report. It took me time to understand them although it is the heart of \vc{} programming.


\subsection{\file{helloworld} Program}

As a consequence of \ref{concepts}, in the case of \keyword{GPU} programing, a \file{helloworld} is not a trivial exercice because a lot of parts are involved. To run \code{code} on \vc, we must write a \cpu{} program (in \keyword{C} language) that will:
\begin{itemize}
	\item initialize the GPU
	\item map shared RAM memory space
	\item configure parameters
	\item send data and code to the GPU
	\item get back resutls
\end{itemize}
\vspace{10 mm}

Within the \file{rpi-playground} project, \file{helloworld} program will:

\begin{itemize}
	\item initialize the \vc
	\item map the RAM memory shared by the \vc{} and the \cpu
	\item transfer a single input value - \keyword{100} - from \cpu{} to \vc
	\item use the \vc{} to add constant  - \keyword{0x1234} - to this input value
	\item get back the result from \vc{} to \cpu
\end{itemize}


\subsubsection{Run \file{helloworld} and see its output}

To execute \file{helloworld}, we run \code{sudo ./helloworld helloworld.bin 100}.

\code{./helloworld} is responsible for mapping memory, initialize \keyword{GPU}, get back results and sends two arguments to the \keyword{GPU}:
\begin{itemize}
	\item \keyword{100} -- the input value
	\item \file{helloworld.bin} -- \code{code-to-execute} by \vc{} that contains \keyword{0x1234} value
\end{itemize}

Finally, program adds \keyword{100} to \keyword{0x1234} and produces the following output:

\lstset{style=CStyle,caption={\file{helloworld} output},captionpos=t}
\begin{lstlisting}
Loaded 80 bytes of code from helloworld.bin ...
QPU enabled.
Uniform value = 100
QPU 0, word 0: 0x00001298
QPU 0, word 1: 0x00001298
QPU 0, word 2: 0x00001298
QPU 0, word 3: 0x00001298
QPU 0, word 4: 0x00001298
QPU 0, word 5: 0x00001298
QPU 0, word 6: 0x00001298
QPU 0, word 7: 0x00001298
QPU 0, word 8: 0x00001298
QPU 0, word 9: 0x00001298
QPU 0, word 10: 0x00001298
QPU 0, word 11: 0x00001298
QPU 0, word 12: 0x00001298
QPU 0, word 13: 0x00001298
QPU 0, word 14: 0x00001298
QPU 0, word 15: 0x00001298
Cleaning up.
Done.
\end{lstlisting}


\subsection{\vc{} Overview}



Appendice~\ref{AppendixC} taken from \parencite{refVC} shows an architecture overview of the \vc. \keyword{GPU} parts involved in \file{helloworld} program are highlighted with \textcolor{blue}{blue} rectangles:




\begin{itemize}
	\item \keyword{AXI ARB} -- bus that connects \vc{} to shared RAM and \cpu
	\item \keyword{Uniforms Cache (QUC)} -- cache containning variables transferred from \cpu{} to \vc
	\item \keyword{Icache (QIC)} -- cache containning code-to-execute transferred from \cpu{} to \vc
	\item \keyword{Quad Processor Unit (QPU)} -- \vc{} internal processor
	\item \keyword{Vertex Pipe Memory (VPM)} -- \vc{} internal memory buffer
	\item \keyword{VPM DMA Writer (VDM)} -- writes DATA from VPM to shared RAM
	\item \keyword{Vertex Cache Manager \& DMA (VCM and VCD)} -- writes DATA from shared RAM to VPM
\end{itemize}
\vspace{5 mm}

\cpu{} and \vc{} communicate through \keyword{AXI ARB} bus. Within \file{helloworld} program, we will use \cpu{} to:
\begin{itemize}
	\item initialize and allocate shared RAM in the \keyword{ARM Virtual Adresses} (Appendice~\ref{AppendixB})
	\item transfer variables to the \keyword{QUC}
	\item transfer code-to-execute to the \keyword{QIC}
	\item execute code with \keyword{QPU}
	\item store result into \keyword{VPM}
	\item write back results into shared RAM through \keyword{VDM}
\end{itemize}


\subsubsection{Quad Processor Unit}

\qpu{} is the \vc{} internal processor. It is the \keyword{key component}. Appendice~\ref{AppendixD} taken from \parencite{refVC} shows its pipeline.

%\begin{figure}[!htbp]
%	\centering
%	\includegraphics[width=0.9\textwidth]{QPU}
%	\caption{\qpu{} pipeline}
%	\label{qpuFigure}
%\end{figure}
%\FloatBarrier

\qpu{} is a \keyword{SIMD} vector processor developed by \textsc{Broadcom} with instructions that operate on 16-element vectors of 32-bit integer or floating point values. For example, given two 16-element vectors:\\

\begin{tabular}{cccc|cccc|cccc|cccc}
	10&11&12&13&14&15&16&17&18&19&20&21&22&23&24&25
\end{tabular}

and

\begin{tabular}{cccc|cccc|cccc|cccc}
	20&21&22&23&24&25&26&27&28&29&30&31&32&33&34&35
\end{tabular}\\

The QPU's \code{integer-add} (Figure~\ref{VCinstructionsFigure}) instruction computes a third vector:

\begin{tabular}{cccc|cccc|cccc|cccc}
	30&32&34&36&38&40&42&44&46&48&50&52&54&56&58&60
\end{tabular}

where each element in the output is the sum of the corresponding two elements in the inputs.\\

Each 16-element vector is comprised of four quads. This is where the name ``Quad Processing Unit'' comes from: a QPU processes one quad per clock cycle, and a QPU instruction takes four consecutive clock cycles to deliver a full 16-element result vector.

\rasp{} contains 12 \qpu{}s in total, each running at 250MHz. That's a max throughput of 750M vector instructions per second (250M cycles divided by 4 cycles-per-instruction times 12 QPUs). Or: 12B operations per second (750M instructions times 16 vector elements). \qpu{} instructions can in some cases deliver two results at a time, so the Pi's QPUs are often advertised at 24 GFLOPS.



\subsection{\file{rpi-playground} Architecture}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.4\textwidth,scale=0.2]{rpiPlaygroundArchitecture}
	\caption{\file{rpi-playground} Architecture}
	\label{rpiPlaygroundFigure}
\end{figure}
\FloatBarrier

Figure~\ref{rpiPlaygroundFigure} shows the architecture of the \file{rpi-playground} project once cloned from the \file{github} repository: \code{git clone git@github.com:elorimer/rpi-playground.git}
The project is made of two directories:
\begin{itemize}
\item \keyword{assembler} directory contains:
	\begin{itemize}
		\item \file{assemble.cpp} -- \keyword{assembly parser} of \vc{} instructions set
	\end{itemize}
\item \keyword{helloworld} directory contains:
	\begin{itemize}
		\item \file{helloworld.asm} -- \code{code-to-execute} on the \vc
		\item \file{driver.c} -- code that \code{drives} the \vc
	\end{itemize}
\end{itemize}



\subsection{\keyword{assembler} directory}


\subsubsection{assemble.cpp}

\file{assemble.cpp} is the \keyword{assembly parser} written by Eric \textsc{Lorimer} the author of \file{rpi-playground} project. This code translates instuctions written in \file{helloworld.asm} (Figure~\ref{rpiPlaygroundFigure}) into \file{helloworld.bin}, a binary file that the \vc{} will understand.

Figure~\ref{VCinstructionsFigure} taken from \parencite{refVC} shows the miscellaneous \enquote{\code{add}} operations of the \qpu. \vc{} has also \enquote{\code{mul}}, \enquote{\code{load}}, \enquote{\code{branch}} or \enquote{\code{semaphore}} instructions.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.6\textwidth]{VCinstructions}
	\caption{Part of \vc{} instructions set}
	\label{VCinstructionsFigure}
\end{figure}
\FloatBarrier

In \file{assemble.cpp}, these instructions are declared with the following \keyword{C++} code:

%\lstset{language=C,caption={Declaration of \enquote{\code{add operations}} in \file{assemble.cpp}},captionpos=t,label=addLabel}
\lstset{style=CStyle,caption={Declaration of \code{add} operations in \file{assemble.cpp}},captionpos=t,label=addLabel}
\begin{lstlisting}
static string addOps[] = {
    "nop", "fadd", "fsub", "fmin", "fmax", "fminabs", "fmaxabs",
    "ftoi", "itof", "XXX", "XXX", "XXX", "add", "sub", "shr",
    "asr", "ror", "shl", "min", "max", "and", "or", "xor", "not",
    "clz", "XXX", "XXX", "XXX", "XXX", "XXX", "v8adds", "v8subs" };
\end{lstlisting}



\subsubsection{Makefile}

\lstset{language=make,caption={Makefile from assembler directory},captionpos=t,label=assMakefileLabel}
\begin{lstlisting}
qpu-assembler: assemble.cpp
	g++ -g -o qpu-assembler assemble.cpp
\end{lstlisting}

This \file{Makefile} contains only one instruction. So running the \code{make} command inside the \keyword{assembler} directory generates \file{qpu-assembler}, an \keyword{executable} file.
\vspace{5 mm}

Then, this \keyword{executable} is used in the \keyword{helloworld} directory to generate \file{helloworld.bin}:

\code{../assembler/qpu-assembler -o helloworld.bin < helloworld.asm}
\vspace{5 mm}



\subsection{\keyword{helloworld} directory}

\subsubsection{qpu.h/qpu.c}

In these files we define a \code{MACRO} function, \code{BUS\_TO\_PHYS()}, to convert \keyword{VC CPU Bus Addresses} into \keyword{ARM Virtual Addresses} (Appendice~\ref{AppendixB}).

Then we use \code{MACROS} to define \keyword{VC CPU Bus Addresses} of \vc{} peripherals.

Finally, we declare \code{gpu\_fft\_get\_host\_info()} to get \rasp{} information.


%\lstset{language=C,caption={qpu.h}}
\lstset{style=CStyle,caption={qpu.h}}
\begin{lstlisting}
#define BUS_TO_PHYS(x) ((x)&~0xC0000000)

#define V3D_L2CACTL (0xC00020>>2)
#define V3D_SLCACTL (0xC00024>>2)
#define V3D_SRQPC   (0xC00430>>2)
#define V3D_SRQUA   (0xC00434>>2)
#define V3D_SRQCS   (0xC0043c>>2)
#define V3D_DBCFG   (0xC00e00>>2)
#define V3D_DBQITE  (0xC00e2c>>2)
#define V3D_DBQITC  (0xC00e30>>2)

int gpu_fft_get_host_info(struct GPU_FFT_HOST *info);
\end{lstlisting}


\subsubsection{helloworld.asm}

\file{helloworld.asm} is the \code{code-to-execute} by the \vc. It is written in \keyword{assembly language} using the \vc{}'s instructions set. Let's explain line by line:\\

\code{\# Load the value we want to add to the input into a register\\ldi ra1, 0x1234}\\
-- First, we load the 32-bit immediate value \emph{0x1234} into \emph{ra1} register.\\
-- This value is replicated 16 ways accross the entire SIMD array of the \emph{QPU 0,0} processor.\\

\code{\# Configure the VPM for writing\\ldi rb49, 0xa0}\\
-- QPU register address map in \parencite{refVC} pages 37-38 shows writting to \emph{rb49} is \code{VPMVCD\_WR\_SETUP}: we configure \keyword{VPM} memory to store results from \emph{QPU 0,0}.\\

\code{\# Add the input value (first uniform - rb32)\\ \# and the register with the hard-coded constant into the VPM.\\add rb48, ra1, rb32; nop}\\
-- \emph{rb48} is the register to write into, in order to write results from the \emph{QPU 0,0} to the \keyword{VPM} the way we just configured it.\\
-- \emph{rb32/ra32} is the address we read from to fetch \keyword{100} -- \keyword{uniform} value.\\

\code{\# Move 16 words (1 vector) back to the host (DMA)\\ldi rb49, 0x88010000}\\
-- From \parencite{refVC} page 58, we configure the \emph{VPM DMA storing} by writing \emph{rb49} register : \code{VPMVCD\_WR\_SETUP}.\\
-- We configure the \emph{DMA} transfer of 16-word vector from \emph{VPM buffer} to the shared RAM memory.\\

\code{\# Initiate the DMA (next uniform, ra32, is the host address to write to)\\or rb50, ra32, 0; nop}\\
\code{\# Wait for the DMA to complete\\or rb39, rb50, ra39; nop}\\
-- Finally, we write the results in the shared RAM memory at the second uniforms address \emph{ra32} register.\\

\code{\# Trigger a host interrupt (writing rb38) to stop the program\\or rb38, ra39, ra39; nop}\\
\code{nop.tend ra39, ra39, ra39; nop rb39, rb39, rb39\\nop ra39, ra39, ra39; nop rb39, rb39, rb39\\nop ra39, ra39, ra39; nop rb39, rb39, rb39}\\
-- The last instructions stops the program.


\subsubsection{driver.c}

The whole \file{driver.c} is written in Appendice~\ref{AppendixE}, but I will detail the \keyword{key parts}:\\


\code{\#include ``mailbox.h''}\\
-- We use \keyword{mailbox interface} to communicate between \vc{} and \cpu.\\
-- This interface uses low-level linux kernel functions that enable \keyword{CPU} to send \code{code-to-execute} and \code{input data} - \keyword{uniforms} - to \keyword{GPU}, and then get back results.\\



\lstset{style=CStyle,caption={helloworld memory\_map}}
\begin{lstlisting}
struct memory_map {
    unsigned int code[MAX_CODE_SIZE];
    unsigned int uniforms[NUM_QPUS][2];
    unsigned int msg[NUM_QPUS][2];
    unsigned int results[NUM_QPUS][16];
};
\end{lstlisting}
-- This defines the memory layout we’ll use and share between \keyword{CPU} and \keyword{GPU}.\\
-- This layout will be accessed in both \emph{ARM Virtual Addresses} and \emph{VC CPU Bus Addresses} (Appencice~\ref{AppendixB}).\\

\code{int code\_words = loadShaderCode(argv[1], qpu\_code, MAX\_CODE\_SIZE);}\\
-- We use \code{loadShaderCode()} function to load \file{helloworld.bin} binary code file.\\~\\

\lstset{style=CStyle,caption={init mailbox interface}}
\begin{lstlisting}
    int mb = mbox_open();
    if (qpu_enable(mb, 1))
    {
        fprintf(stderr, "QPU enable failed.\n");
        return -1;
    }
    printf("QPU enabled.\n");

    unsigned size = 1024 * 1024;
    unsigned handle = mem_alloc(mb, size, 4096, host.mem_flg);
    if (!handle)
    {
        fprintf(stderr, "Unable to allocate %d bytes of GPU memory", size);
        return -2;
    }

    unsigned ptr = mem_lock(mb, handle);
\end{lstlisting}

-- Initialize the \keyword{mailbox} interface and send a message to enable the \qpu{} with the \code{qpu\_enable()} mailbox's function\\
-- We allocate and lock GPU memory with \code{mem\_alloc()} mailbox's function\\
-- \emph{ptr} is now the base Bus Address of the GPU memory mapping\\
-- \emph{ptr} is located inside \emph{VC CPU BUS Addresses} (Appendice~\ref{AppendixB})\\

\code{void *arm\_ptr = mapmem(BUS\_TO\_PHYS(ptr + host.mem\_map), size);}\\
-- Keep in mind that \vc{} is an \cpu{} peripheral. As a consequence, we first map the memory layout from \emph{ptr} into \emph{ARM Virtual Addresses} with \code{mapmem()} function\\

\lstset{style=CStyle,caption={pointer arithmetic}}
\begin{lstlisting}
    // assert arm_ptr ...
    struct memory_map *arm_map = (struct memory_map *)arm_ptr;
    memset(arm_map, 0x0, sizeof(struct memory_map));

    unsigned vc_uniforms = ptr + offsetof(struct memory_map, uniforms);
    unsigned vc_code = ptr + offsetof(struct memory_map, code);
    unsigned vc_msg = ptr + offsetof(struct memory_map, msg);
    unsigned vc_results = ptr + offsetof(struct memory_map, results);
    memcpy(arm_map->code, qpu_code, code_words * sizeof(unsigned int));
\end{lstlisting}
-- We make pointer arithmetic to create the same mapping inside \emph{VC CPU Bus Addresses} to communicate with the \keyword{GPU}\\
-- Now we have two addresses (Appendice~\ref{AppendixB}) to refer to the memory:
\begin{itemize}
\item \emph{ptr} is address that the \vc{} understands in \emph{VC CPU Bus Addresses}. When passing pointers to \keyword{GPU} we need to use THOSE \emph{vc\_addresses}
\item \emph{arm\_map} is used when accessing the memory from the host \cpu. This is a valid \keyword{CPU} address
\end{itemize}

\lstset{style=CStyle,caption={Transfer uniforms, code-to-execute and execute\_qpu}}
\begin{lstlisting}
    for (int i = 0; i < NUM_QPUS; i++)
    {
        arm_map->uniforms[i][0] = uniform_val;
        arm_map->uniforms[i][1] = vc_results + i * sizeof(unsigned) * 16;
        arm_map->msg[i][0] = vc_uniforms + i * sizeof(unsigned) * 2;
        arm_map->msg[i][1] = vc_code;
    }

    unsigned ret = execute_qpu(mb, NUM_QPUS, vc_msg, GPU_FFT_NO_FLUSH,
                               GPU_FFT_TIMEOUT);
\end{lstlisting}
-- To execute a \qpu{} program on the \keyword{GPU}, we pass an array of message structures \emph{vc\_msg}, through \code{execute\_qpu()} function from the \keyword{mailbox} interface. This array contains:
\begin{itemize}
	\item First - \emph{vc\_uniforms} - a pointer to all the uniforms to bind to the QPU program
	\begin{itemize}
		\item \emph{uniform\_val} - 100
		\item \emph{vc\_results} - address of \code{results[NUM\_QPU][16]} in \emph{VC CPU Bus Addresses}
	\end{itemize}
\item Then - \emph{vc\_code} - a pointer to the address of the \code{code-to-execute} on QPU.
\end{itemize}


\subsection{Summary}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{helloworldDataFlow}
	\caption{\file{helloworld} execution diagram}
	\label{flowFigure}
\end{figure}
\FloatBarrier


Figure~\ref{flowFigure} sums up the \file{helloworld} program execution:

\begin{itemize}
	\item We use two \keyword{uniforms} to transfer:
		\begin{itemize}
			\item input value - \emph{100}
			\item results array address - \emph{results[NUM\_QPUS][16]}
		\end{itemize}
		from the host \cpu{} to the \emph{QPU 0,0} through the \keyword{mailbox} interface (\code{execute\_qpu()} function in \file{driver.c}). These 2 uniforms will be load into \emph{QUC : Uniforms Cache}.
	\item We also use \keyword{mailbox} interface to tranfer \code{code-to-execute} to the \keyword{GPU}. \code{code-to-execute} is then load into \emph{QIC : Icache (Instructions cache)}.
	\item \emph{QPU 0,0} adds \emph{100} to \emph{0x1234}.
	\item The result (16-word vector) is sent back to \keyword{VPM} (Vertex Pipe Memory).
	\item The result (16-word vector) is write back from \keyword{VPM} to shared RAM memory through \keyword{DMA} transfer.
\end{itemize}


\subsection{Conclusion}

This project taught me the basis of \vc{} programming and laid the groundwork for the rest of my internship. I understood that:
\begin{itemize}
	\item GPU and CPU share the same RAM memory - Appendice~\ref{AppendixB}:
		\begin{itemize}
			\item CPU sends code and data in \emph{VC CPU Bus Addresses}
			\item GPU gives back results in \emph{ARM Virtual Addresses}
		\end{itemize}
	\item GPU is driven by CPU program (\file{driver.c}) that:
		\begin{itemize}
			\item initialize GPU
			\item map shared memory
			\item send code and data
			\item get back results
		\end{itemize}
	\item GPU and CPU communicate via \keyword{mailbox}:
		\begin{itemize}
			\item \keyword{API} that uses low-level linux kernel functions
			\item source code is available in the raspbian distribution: \code{}
		\end{itemize}
	\item GPU processor is called QPU - Appendice~\ref{AppendixD}:
		\begin{itemize}
			\item SIMD processors -- operates on 16-words vector
			\item 12 QPUs on \vc
		\end{itemize}
	\item GPU is fitted with - Appendice~\ref{AppendixC}:
		\begin{itemize}
			\item VPM to store result from QPU
			\item DMA to send result from VPM to shared RAM memory
		\end{itemize}
	\item To run program on GPU:
		\begin{itemize}
			\item \code{code-to-execute} is written in \keyword{assembly language} - \file{helloworld.asm}
			\item \code{code-to-execute} is translate into \keyword{binary} file - \file{helloworld.bin}
			\item \code{code-to-execute} is sent to \keyword{GPU} with other variables called \code{uniforms}
		\end{itemize}
\end{itemize}

To build the homemade \keyword{API} for \iBubble, I focused on:
\begin{itemize}
	\item improve \file{driver.c}
	\item refactore project architecture
	\item use a more comprehensive \keyword{assembly parser} than \file{assemble.cpp}
	\item find new \vc{} features
	\item include my source code in \keyword{C++} project
\end{itemize}

%----------------------------------------------------------------------------------------

\section{\emph{pi-gemm} Project}

This project \parencite{refPiGemm}
If you are familiar with \LaTeX{}, then you should explore the directory structure of the template and then proceed to place your own information into the \emph{THESIS INFORMATION} block of the \file{main.tex} file. You can then modify the rest of this file to your unique specifications based on your degree/university. Section \ref{FillingFile} on page \pageref{FillingFile} will help you do this. Make sure you also read section \ref{ThesisConventions} about thesis conventions to get the most out of this template.

If you are new to \LaTeX{} it is recommended that you carry on reading through the rest of the information in this document.

Before you begin using this template you should ensure that its style complies with the thesis style guidelines imposed by your institution. In most cases this template style and layout will be suitable. If it is not, it may only require a small change to bring the template in line with your institution's recommendations. These modifications will need to be done on the \file{MastersDoctoralThesis.cls} file.

\subsection{About this Template}

This \LaTeX{} Thesis Template is originally based and created around a \LaTeX{} style file created by Steve R.\ Gunn from the University of Southampton (UK), department of Electronics and Computer Science. You can find his original thesis style file at his site, here:
\url{http://www.ecs.soton.ac.uk/~srg/softwaretools/document/templates/}

Steve's \file{ecsthesis.cls} was then taken by Sunil Patel who modified it by creating a skeleton framework and folder structure to place the thesis files in. The resulting template can be found on Sunil's site here:
\url{http://www.sunilpatel.co.uk/thesis-template}

Sunil's template was made available through \url{http://www.LaTeXTemplates.com} where it was modified many times based on user requests and questions. Version 2.0 and onwards of this template represents a major modification to Sunil's template and is, in fact, hardly recognisable. The work to make version 2.0 possible was carried out by \href{mailto:vel@latextemplates.com}{Vel} and Johannes Böttcher.

%----------------------------------------------------------------------------------------

\section{Gradient Descent Algorithm}

\subsection{Pyramid}

This template comes as a single zip file that expands out to several files and folders. The folder names are mostly self-explanatory:

\keyword{Appendices} -- this is the folder where you put the appendices. Each appendix should go into its own separate \file{.tex} file. An example and template are included in the directory.

\keyword{Chapters} -- this is the folder where you put the thesis chapters. A thesis usually has about six chapters, though there is no hard rule on this. Each chapter should go in its own separate \file{.tex} file and they can be split as:
\begin{itemize}
\item Chapter 1: Introduction to the thesis topic
\item Chapter 2: Background information and theory
\item Chapter 3: (Laboratory) experimental setup
\item Chapter 4: Details of experiment 1
\item Chapter 5: Details of experiment 2
\item Chapter 6: Discussion of the experimental results
\item Chapter 7: Conclusion and future directions
\end{itemize}
This chapter layout is specialised for the experimental sciences, your discipline may be different.

\keyword{Figures} -- this folder contains all figures for the thesis. These are the final images that will go into the thesis document.

\subsection{Gradient Descent}

Included are also several files, most of them are plain text and you can see their contents in a text editor. After initial compilation, you will see that more auxiliary files are created by \LaTeX{} or BibTeX and which you don't need to delete or worry about:

\keyword{example.bib} -- this is an important file that contains all the bibliographic information and references that you will be citing in the thesis for use with BibTeX. You can write it manually, but there are reference manager programs available that will create and manage it for you. Bibliographies in \LaTeX{} are a large subject and you may need to read about BibTeX before starting with this. Many modern reference managers will allow you to export your references in BibTeX format which greatly eases the amount of work you have to do.

\keyword{MastersDoctoralThesis.cls} -- this is an important file. It is the class file that tells \LaTeX{} how to format the thesis.

\keyword{main.pdf} -- this is your beautifully typeset thesis (in the PDF file format) created by \LaTeX{}. It is supplied in the PDF with the template and after you compile the template you should get an identical version.

\keyword{main.tex} -- this is an important file. This is the file that you tell \LaTeX{} to compile to produce your thesis as a PDF file. It contains the framework and constructs that tell \LaTeX{} how to layout the thesis. It is heavily commented so you can read exactly what each line of code does and why it is there. After you put your own information into the \emph{THESIS INFORMATION} block -- you have now started your thesis!

Files that are \emph{not} included, but are created by \LaTeX{} as auxiliary files include:

\keyword{main.aux} -- this is an auxiliary file generated by \LaTeX{}, if it is deleted \LaTeX{} simply regenerates it when you run the main \file{.tex} file.

\keyword{main.bbl} -- this is an auxiliary file generated by BibTeX, if it is deleted, BibTeX simply regenerates it when you run the \file{main.aux} file. Whereas the \file{.bib} file contains all the references you have, this \file{.bbl} file contains the references you have actually cited in the thesis and is used to build the bibliography section of the thesis.

\keyword{main.blg} -- this is an auxiliary file generated by BibTeX, if it is deleted BibTeX simply regenerates it when you run the main \file{.aux} file.

\keyword{main.lof} -- this is an auxiliary file generated by \LaTeX{}, if it is deleted \LaTeX{} simply regenerates it when you run the main \file{.tex} file. It tells \LaTeX{} how to build the \emph{List of Figures} section.

\keyword{main.log} -- this is an auxiliary file generated by \LaTeX{}, if it is deleted \LaTeX{} simply regenerates it when you run the main \file{.tex} file. It contains messages from \LaTeX{}, if you receive errors and warnings from \LaTeX{}, they will be in this \file{.log} file.

\keyword{main.lot} -- this is an auxiliary file generated by \LaTeX{}, if it is deleted \LaTeX{} simply regenerates it when you run the main \file{.tex} file. It tells \LaTeX{} how to build the \emph{List of Tables} section.

\keyword{main.out} -- this is an auxiliary file generated by \LaTeX{}, if it is deleted \LaTeX{} simply regenerates it when you run the main \file{.tex} file.

So from this long list, only the files with the \file{.bib}, \file{.cls} and \file{.tex} extensions are the most important ones. The other auxiliary files can be ignored or deleted as \LaTeX{} and BibTeX will regenerate them.

%----------------------------------------------------------------------------------------

\section{Other Tasks}\label{FillingFile}

You will need to personalise the thesis template and make it your own by filling in your own information. This is done by editing the \file{main.tex} file in a text editor or your favourite LaTeX environment.

Open the file and scroll down to the third large block titled \emph{THESIS INFORMATION} where you can see the entries for \emph{University Name}, \emph{Department Name}, etc \ldots

Fill out the information about yourself, your group and institution. You can also insert web links, if you do, make sure you use the full URL, including the \code{http://} for this. If you don't want these to be linked, simply remove the \verb|\href{url}{name}| and only leave the name.

When you have done this, save the file and recompile \code{main.tex}. All the information you filled in should now be in the PDF, complete with web links. You can now begin your thesis proper!

\subsection{gitHub}

\subsection{Linux}

%----------------------------------------------------------------------------------------

\section{The \code{main.tex} File Explained}

The \file{main.tex} file contains the structure of the thesis. There are plenty of written comments that explain what pages, sections and formatting the \LaTeX{} code is creating. Each major document element is divided into commented blocks with titles in all capitals to make it obvious what the following bit of code is doing. Initially there seems to be a lot of \LaTeX{} code, but this is all formatting, and it has all been taken care of so you don't have to do it.

Begin by checking that your information on the title page is correct. For the thesis declaration, your institution may insist on something different than the text given. If this is the case, just replace what you see with what is required in the \emph{DECLARATION PAGE} block.

Then comes a page which contains a funny quote. You can put your own, or quote your favourite scientist, author, person, and so on. Make sure to put the name of the person who you took the quote from.

Following this is the abstract page which summarises your work in a condensed way and can almost be used as a standalone document to describe what you have done. The text you write will cause the heading to move up so don't worry about running out of space.

Next come the acknowledgements. On this page, write about all the people who you wish to thank (not forgetting parents, partners and your advisor/supervisor).

The contents pages, list of figures and tables are all taken care of for you and do not need to be manually created or edited. The next set of pages are more likely to be optional and can be deleted since they are for a more technical thesis: insert a list of abbreviations you have used in the thesis, then a list of the physical constants and numbers you refer to and finally, a list of mathematical symbols used in any formulae. Making the effort to fill these tables means the reader has a one-stop place to refer to instead of searching the internet and references to try and find out what you meant by certain abbreviations or symbols.

The list of symbols is split into the Roman and Greek alphabets. Whereas the abbreviations and symbols ought to be listed in alphabetical order (and this is \emph{not} done automatically for you) the list of physical constants should be grouped into similar themes.

The next page contains a one line dedication. Who will you dedicate your thesis to?

Finally, there is the block where the chapters are included. Uncomment the lines (delete the \code{\%} character) as you write the chapters. Each chapter should be written in its own file and put into the \emph{Chapters} folder and named \file{Chapter1}, \file{Chapter2}, etc\ldots Similarly for the appendices, uncomment the lines as you need them. Each appendix should go into its own file and placed in the \emph{Appendices} folder.

After the preamble, chapters and appendices finally comes the bibliography. The bibliography style (called \option{authoryear}) is used for the bibliography and is a fully featured style that will even include links to where the referenced paper can be found online. Do not underestimate how grateful your reader will be to find that a reference to a paper is just a click away. Of course, this relies on you putting the URL information into the BibTeX file in the first place.

%----------------------------------------------------------------------------------------

\section{Thesis Features and Conventions}\label{ThesisConventions}

To get the best out of this template, there are a few conventions that you may want to follow.

One of the most important (and most difficult) things to keep track of in such a long document as a thesis is consistency. Using certain conventions and ways of doing things (such as using a Todo list) makes the job easier. Of course, all of these are optional and you can adopt your own method.

\subsection{Printing Format}

This thesis template is designed for double sided printing (i.e. content on the front and back of pages) as most theses are printed and bound this way. Switching to one sided printing is as simple as uncommenting the \option{oneside} option of the \code{documentclass} command at the top of the \file{main.tex} file. You may then wish to adjust the margins to suit specifications from your institution.

The headers for the pages contain the page number on the outer side (so it is easy to flick through to the page you want) and the chapter name on the inner side.

The text is set to 11 point by default with single line spacing, again, you can tune the text size and spacing should you want or need to using the options at the very start of \file{main.tex}. The spacing can be changed similarly by replacing the \option{singlespacing} with \option{onehalfspacing} or \option{doublespacing}.

\subsection{Using US Letter Paper}

The paper size used in the template is A4, which is the standard size in Europe. If you are using this thesis template elsewhere and particularly in the United States, then you may have to change the A4 paper size to the US Letter size. This can be done in the margins settings section in \file{main.tex}.

Due to the differences in the paper size, the resulting margins may be different to what you like or require (as it is common for institutions to dictate certain margin sizes). If this is the case, then the margin sizes can be tweaked by modifying the values in the same block as where you set the paper size. Now your document should be set up for US Letter paper size with suitable margins.

\subsection{References}

The \code{biblatex} package is used to format the bibliography and inserts references such as this one \parencite{Reference4}. The options used in the \file{main.tex} file mean that the in-text citations of references are formatted with the author(s) listed with the date of the publication. Multiple references are separated by semicolons (e.g. \parencite{Reference2, Reference1}) and references with more than three authors only show the first author with \emph{et al.} indicating there are more authors (e.g. \parencite{Reference3}). This is done automatically for you. To see how you use references, have a look at the \file{Chapter1.tex} source file. Many reference managers allow you to simply drag the reference into the document as you type.

Scientific references should come \emph{before} the punctuation mark if there is one (such as a comma or period). The same goes for footnotes\footnote{Such as this footnote, here down at the bottom of the page.}. You can change this but the most important thing is to keep the convention consistent throughout the thesis. Footnotes themselves should be full, descriptive sentences (beginning with a capital letter and ending with a full stop). The APA6 states: \enquote{Footnote numbers should be superscripted, [...], following any punctuation mark except a dash.} The Chicago manual of style states: \enquote{A note number should be placed at the end of a sentence or clause. The number follows any punctuation mark except the dash, which it precedes. It follows a closing parenthesis.}

The bibliography is typeset with references listed in alphabetical order by the first author's last name. This is similar to the APA referencing style. To see how \LaTeX{} typesets the bibliography, have a look at the very end of this document (or just click on the reference number links in in-text citations).

\subsubsection{A Note on bibtex}

The bibtex backend used in the template by default does not correctly handle unicode character encoding (i.e. "international" characters). You may see a warning about this in the compilation log and, if your references contain unicode characters, they may not show up correctly or at all. The solution to this is to use the biber backend instead of the outdated bibtex backend. This is done by finding this in \file{main.tex}: \option{backend=bibtex} and changing it to \option{backend=biber}. You will then need to delete all auxiliary BibTeX files and navigate to the template directory in your terminal (command prompt). Once there, simply type \code{biber main} and biber will compile your bibliography. You can then compile \file{main.tex} as normal and your bibliography will be updated. An alternative is to set up your LaTeX editor to compile with biber instead of bibtex, see \href{http://tex.stackexchange.com/questions/154751/biblatex-with-biber-configuring-my-editor-to-avoid-undefined-citations/}{here} for how to do this for various editors.

\subsection{Tables}

Tables are an important way of displaying your results, below is an example table which was generated with this code:

{\small
\begin{verbatim}
\begin{table}
\caption{The effects of treatments X and Y on the four groups studied.}
\label{tab:treatments}
\centering
\begin{tabular}{l l l}
\toprule
\tabhead{Groups} & \tabhead{Treatment X} & \tabhead{Treatment Y} \\
\midrule
1 & 0.2 & 0.8\\
2 & 0.17 & 0.7\\
3 & 0.24 & 0.75\\
4 & 0.68 & 0.3\\
\bottomrule\\
\end{tabular}
\end{table}
\end{verbatim}
}

\begin{table}
\caption{The effects of treatments X and Y on the four groups studied.}
\label{tab:treatments}
\centering
\begin{tabular}{l l l}
\toprule
\tabhead{Groups} & \tabhead{Treatment X} & \tabhead{Treatment Y} \\
\midrule
1 & 0.2 & 0.8\\
2 & 0.17 & 0.7\\
3 & 0.24 & 0.75\\
4 & 0.68 & 0.3\\
\bottomrule\\
\end{tabular}
\end{table}

You can reference tables with \verb|\ref{<label>}| where the label is defined within the table environment. See \file{Chapter1.tex} for an example of the label and citation (e.g. Table~\ref{tab:treatments}).

\subsection{Figures}

There will hopefully be many figures in your thesis (that should be placed in the \emph{Figures} folder). The way to insert figures into your thesis is to use a code template like this:
\begin{verbatim}
\begin{figure}
\centering
\includegraphics{Figures/Electron}
\decoRule
\caption[An Electron]{An electron (artist's impression).}
\label{fig:Electron}
\end{figure}
\end{verbatim}
Also look in the source file. Putting this code into the source file produces the picture of the electron that you can see in the figure below.

\begin{figure}[th]
\centering
\includegraphics{Figures/Electron}
\decoRule
\caption[An Electron]{An electron (artist's impression).}
\label{fig:Electron}
\end{figure}

Sometimes figures don't always appear where you write them in the source. The placement depends on how much space there is on the page for the figure. Sometimes there is not enough room to fit a figure directly where it should go (in relation to the text) and so \LaTeX{} puts it at the top of the next page. Positioning figures is the job of \LaTeX{} and so you should only worry about making them look good!

Figures usually should have captions just in case you need to refer to them (such as in Figure~\ref{fig:Electron}). The \verb|\caption| command contains two parts, the first part, inside the square brackets is the title that will appear in the \emph{List of Figures}, and so should be short. The second part in the curly brackets should contain the longer and more descriptive caption text.

The \verb|\decoRule| command is optional and simply puts an aesthetic horizontal line below the image. If you do this for one image, do it for all of them.

\LaTeX{} is capable of using images in pdf, jpg and png format.

\subsection{Typesetting mathematics}

If your thesis is going to contain heavy mathematical content, be sure that \LaTeX{} will make it look beautiful, even though it won't be able to solve the equations for you.

The \enquote{Not So Short Introduction to \LaTeX} (available on \href{http://www.ctan.org/tex-archive/info/lshort/english/lshort.pdf}{CTAN}) should tell you everything you need to know for most cases of typesetting mathematics. If you need more information, a much more thorough mathematical guide is available from the AMS called, \enquote{A Short Math Guide to \LaTeX} and can be downloaded from:
\url{ftp://ftp.ams.org/pub/tex/doc/amsmath/short-math-guide.pdf}

There are many different \LaTeX{} symbols to remember, luckily you can find the most common symbols in \href{http://ctan.org/pkg/comprehensive}{The Comprehensive \LaTeX~Symbol List}.

You can write an equation, which is automatically given an equation number by \LaTeX{} like this:
\begin{verbatim}
\begin{equation}
E = mc^{2}
\label{eqn:Einstein}
\end{equation}
\end{verbatim}

This will produce Einstein's famous energy-matter equivalence equation:
\begin{equation}
E = mc^{2}
\label{eqn:Einstein}
\end{equation}

All equations you write (which are not in the middle of paragraph text) are automatically given equation numbers by \LaTeX{}. If you don't want a particular equation numbered, use the unnumbered form:
\begin{verbatim}
\[ a^{2}=4 \]
\end{verbatim}

%----------------------------------------------------------------------------------------

\section{Sectioning and Subsectioning}

You should break your thesis up into nice, bite-sized sections and subsections. \LaTeX{} automatically builds a table of Contents by looking at all the \verb|\chapter{}|, \verb|\section{}|  and \verb|\subsection{}| commands you write in the source.

The Table of Contents should only list the sections to three (3) levels. A \verb|chapter{}| is level zero (0). A \verb|\section{}| is level one (1) and so a \verb|\subsection{}| is level two (2). In your thesis it is likely that you will even use a \verb|subsubsection{}|, which is level three (3). The depth to which the Table of Contents is formatted is set within \file{MastersDoctoralThesis.cls}. If you need this changed, you can do it in \file{main.tex}.

%----------------------------------------------------------------------------------------

\section{In Closing}

You have reached the end of this mini-guide. You can now rename or overwrite this pdf file and begin writing your own \file{Chapter1.tex} and the rest of your thesis. The easy work of setting up the structure and framework has been taken care of for you. It's now your job to fill it out!

Good luck and have lots of fun!

\begin{flushright}
Guide written by ---\\
Sunil Patel: \href{http://www.sunilpatel.co.uk}{www.sunilpatel.co.uk}\\
Vel: \href{http://www.LaTeXTemplates.com}{LaTeXTemplates.com}
\end{flushright}
